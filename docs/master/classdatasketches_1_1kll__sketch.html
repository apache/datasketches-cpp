<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>datasketches-cpp: kll_sketch&lt; T, C, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">datasketches-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedatasketches.html">datasketches</a></li><li class="navelem"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdatasketches_1_1kll__sketch-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kll_sketch&lt; T, C, A &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of a very compact quantiles sketch with lazy compaction scheme and nearly optimal accuracy per retained item.  
 <a href="classdatasketches_1_1kll__sketch.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kll__sketch_8hpp_source.html">kll_sketch.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa796209b1ef5dc41e83ed8158f77d280" id="r_aa796209b1ef5dc41e83ed8158f77d280"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#aa796209b1ef5dc41e83ed8158f77d280">quantile_return_type</a> = typename <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, C, A &gt;::quantile_return_type</td></tr>
<tr class="memdesc:aa796209b1ef5dc41e83ed8158f77d280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantile return type.  <br /></td></tr>
<tr class="separator:aa796209b1ef5dc41e83ed8158f77d280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afca1c904b4598d7a9548a40a802ed2b4" id="r_afca1c904b4598d7a9548a40a802ed2b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#afca1c904b4598d7a9548a40a802ed2b4">kll_sketch</a> (uint16_t k=<a class="el" href="namespacedatasketches_1_1kll__constants.html#ac8602cb1bd28fc26ae74b484e81a9a52">kll_constants::DEFAULT_K</a>, const C &amp;comparator=C(), const A &amp;allocator=A())</td></tr>
<tr class="memdesc:afca1c904b4598d7a9548a40a802ed2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:afca1c904b4598d7a9548a40a802ed2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7352580134284b937cb2510d192434e" id="r_af7352580134284b937cb2510d192434e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#af7352580134284b937cb2510d192434e">kll_sketch</a> (const <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;other)</td></tr>
<tr class="memdesc:af7352580134284b937cb2510d192434e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:af7352580134284b937cb2510d192434e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53c0366552f3211d54e4746e12f1fe" id="r_acd53c0366552f3211d54e4746e12f1fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#acd53c0366552f3211d54e4746e12f1fe">kll_sketch</a> (<a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:acd53c0366552f3211d54e4746e12f1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:acd53c0366552f3211d54e4746e12f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d934088182b8615c2fa34a4716d7d44" id="r_a0d934088182b8615c2fa34a4716d7d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a0d934088182b8615c2fa34a4716d7d44">operator=</a> (const <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;other)</td></tr>
<tr class="memdesc:a0d934088182b8615c2fa34a4716d7d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <br /></td></tr>
<tr class="separator:a0d934088182b8615c2fa34a4716d7d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0bad718ea491dd8176196d4b250ff4" id="r_a3b0bad718ea491dd8176196d4b250ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a3b0bad718ea491dd8176196d4b250ff4">operator=</a> (<a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a3b0bad718ea491dd8176196d4b250ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="separator:a3b0bad718ea491dd8176196d4b250ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200c74c52ee0f76d0d34c1ca6aec65c" id="r_a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memTemplParams" colspan="2">template&lt;typename FwdT &gt; </td></tr>
<tr class="memitem:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a5200c74c52ee0f76d0d34c1ca6aec65c">update</a> (FwdT &amp;&amp;item)</td></tr>
<tr class="memdesc:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates this sketch with the given data item.  <br /></td></tr>
<tr class="separator:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb19e78f36fb72b8496cd6cff71fec" id="r_a49bb19e78f36fb72b8496cd6cff71fec"><td class="memTemplParams" colspan="2">template&lt;typename FwdSk &gt; </td></tr>
<tr class="memitem:a49bb19e78f36fb72b8496cd6cff71fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a49bb19e78f36fb72b8496cd6cff71fec">merge</a> (FwdSk &amp;&amp;other)</td></tr>
<tr class="memdesc:a49bb19e78f36fb72b8496cd6cff71fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges another sketch into this one.  <br /></td></tr>
<tr class="separator:a49bb19e78f36fb72b8496cd6cff71fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b7a58dc85678d08752945ff655362" id="r_a5a2b7a58dc85678d08752945ff655362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a5a2b7a58dc85678d08752945ff655362">is_empty</a> () const</td></tr>
<tr class="memdesc:a5a2b7a58dc85678d08752945ff655362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this sketch is empty.  <br /></td></tr>
<tr class="separator:a5a2b7a58dc85678d08752945ff655362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f4c39b9f2e762e8e3445ef89e1d264" id="r_a59f4c39b9f2e762e8e3445ef89e1d264"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a59f4c39b9f2e762e8e3445ef89e1d264">get_k</a> () const</td></tr>
<tr class="memdesc:a59f4c39b9f2e762e8e3445ef89e1d264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns configured parameter k.  <br /></td></tr>
<tr class="separator:a59f4c39b9f2e762e8e3445ef89e1d264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af857be9469a7565252626f27e1f9d74d" id="r_af857be9469a7565252626f27e1f9d74d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#af857be9469a7565252626f27e1f9d74d">get_n</a> () const</td></tr>
<tr class="memdesc:af857be9469a7565252626f27e1f9d74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the input stream.  <br /></td></tr>
<tr class="separator:af857be9469a7565252626f27e1f9d74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa76458d81a17dbebfcb828e531f14" id="r_a31fa76458d81a17dbebfcb828e531f14"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a31fa76458d81a17dbebfcb828e531f14">get_num_retained</a> () const</td></tr>
<tr class="memdesc:a31fa76458d81a17dbebfcb828e531f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of retained items (samples) in the sketch.  <br /></td></tr>
<tr class="separator:a31fa76458d81a17dbebfcb828e531f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a04b1d7dccb3d9b3f3c3d087aa8e6" id="r_ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#ae95a04b1d7dccb3d9b3f3c3d087aa8e6">is_estimation_mode</a> () const</td></tr>
<tr class="memdesc:ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this sketch is in estimation mode.  <br /></td></tr>
<tr class="separator:ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f3769ba3fae6fa0e8a0bd65fef5422" id="r_aa3f3769ba3fae6fa0e8a0bd65fef5422"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#aa3f3769ba3fae6fa0e8a0bd65fef5422">get_min_item</a> () const</td></tr>
<tr class="memdesc:aa3f3769ba3fae6fa0e8a0bd65fef5422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the min item of the stream.  <br /></td></tr>
<tr class="separator:aa3f3769ba3fae6fa0e8a0bd65fef5422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdb10e4f2949d55d29421c6e381a300" id="r_a4cdb10e4f2949d55d29421c6e381a300"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a4cdb10e4f2949d55d29421c6e381a300">get_max_item</a> () const</td></tr>
<tr class="memdesc:a4cdb10e4f2949d55d29421c6e381a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max item of the stream.  <br /></td></tr>
<tr class="separator:a4cdb10e4f2949d55d29421c6e381a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f89979daa6471a3868cb97ea99b40" id="r_a076f89979daa6471a3868cb97ea99b40"><td class="memItemLeft" align="right" valign="top">C&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a076f89979daa6471a3868cb97ea99b40">get_comparator</a> () const</td></tr>
<tr class="memdesc:a076f89979daa6471a3868cb97ea99b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the comparator for this sketch.  <br /></td></tr>
<tr class="separator:a076f89979daa6471a3868cb97ea99b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d85cf47c4ecd0580ec623c42006dd1b" id="r_a9d85cf47c4ecd0580ec623c42006dd1b"><td class="memItemLeft" align="right" valign="top">A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a9d85cf47c4ecd0580ec623c42006dd1b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a9d85cf47c4ecd0580ec623c42006dd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the allocator for this sketch.  <br /></td></tr>
<tr class="separator:a9d85cf47c4ecd0580ec623c42006dd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02fcfb6e706148458a2ef89390223a9" id="r_ac02fcfb6e706148458a2ef89390223a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1kll__sketch.html#aa796209b1ef5dc41e83ed8158f77d280">quantile_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#ac02fcfb6e706148458a2ef89390223a9">get_quantile</a> (double rank, bool inclusive=true) const</td></tr>
<tr class="memdesc:ac02fcfb6e706148458a2ef89390223a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an item from the sketch that is the best approximation to an item from the original stream with the given rank.  <br /></td></tr>
<tr class="separator:ac02fcfb6e706148458a2ef89390223a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849dfa06c183fd2fdfe4fe4a7e29d918" id="r_a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a849dfa06c183fd2fdfe4fe4a7e29d918">get_rank</a> (const T &amp;item, bool inclusive=true) const</td></tr>
<tr class="memdesc:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the normalized rank of the given item from 0 to 1, inclusive.  <br /></td></tr>
<tr class="separator:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44226b755e73883ea2c128876e35b1d1" id="r_a44226b755e73883ea2c128876e35b1d1"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a44226b755e73883ea2c128876e35b1d1">get_PMF</a> (const T *split_points, uint32_t size, bool inclusive=true) const</td></tr>
<tr class="memdesc:a44226b755e73883ea2c128876e35b1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items).  <br /></td></tr>
<tr class="separator:a44226b755e73883ea2c128876e35b1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4d992209b2aa58614c998d143705c" id="r_a20a4d992209b2aa58614c998d143705c"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a20a4d992209b2aa58614c998d143705c">get_CDF</a> (const T *split_points, uint32_t size, bool inclusive=true) const</td></tr>
<tr class="memdesc:a20a4d992209b2aa58614c998d143705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items).  <br /></td></tr>
<tr class="separator:a20a4d992209b2aa58614c998d143705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ba9502b0403ad4448d649ce29b850" id="r_ae08ba9502b0403ad4448d649ce29b850"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#ae08ba9502b0403ad4448d649ce29b850">get_normalized_rank_error</a> (bool pmf) const</td></tr>
<tr class="memdesc:ae08ba9502b0403ad4448d649ce29b850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the approximate rank error of this sketch normalized as a fraction between zero and one.  <br /></td></tr>
<tr class="separator:ae08ba9502b0403ad4448d649ce29b850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716" id="r_ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt; std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#ad9a5259d93d148b5c2050d68e7788716">get_serialized_size_bytes</a> (const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:ad9a5259d93d148b5c2050d68e7788716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size needed to serialize the current state of the sketch.  <br /></td></tr>
<tr class="separator:ad9a5259d93d148b5c2050d68e7788716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716" id="r_ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#ad9a5259d93d148b5c2050d68e7788716">get_serialized_size_bytes</a> (const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:ad9a5259d93d148b5c2050d68e7788716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size needed to serialize the current state of the sketch.  <br /></td></tr>
<tr class="separator:ad9a5259d93d148b5c2050d68e7788716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538940c100e4353b3671ad452d3d3056" id="r_a538940c100e4353b3671ad452d3d3056"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a538940c100e4353b3671ad452d3d3056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a538940c100e4353b3671ad452d3d3056">serialize</a> (std::ostream &amp;os, const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:a538940c100e4353b3671ad452d3d3056"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method serializes the sketch into a given stream in a binary form.  <br /></td></tr>
<tr class="separator:a538940c100e4353b3671ad452d3d3056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c269c23926e93b1c7a9c00e86af97" id="r_a1d0c269c23926e93b1c7a9c00e86af97"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1d0c269c23926e93b1c7a9c00e86af97"><td class="memTemplItemLeft" align="right" valign="top">vector_bytes&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a1d0c269c23926e93b1c7a9c00e86af97">serialize</a> (unsigned header_size_bytes=0, const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:a1d0c269c23926e93b1c7a9c00e86af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method serializes the sketch as a vector of bytes.  <br /></td></tr>
<tr class="separator:a1d0c269c23926e93b1c7a9c00e86af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a7af55659ff803b26a45552a68dda" id="r_a592a7af55659ff803b26a45552a68dda"><td class="memItemLeft" align="right" valign="top">string&lt; A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a592a7af55659ff803b26a45552a68dda">to_string</a> (bool print_levels=false, bool print_items=false) const</td></tr>
<tr class="memdesc:a592a7af55659ff803b26a45552a68dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of the sketch.  <br /></td></tr>
<tr class="separator:a592a7af55659ff803b26a45552a68dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288af208cb43c6bdd67b788dc92037ea" id="r_a288af208cb43c6bdd67b788dc92037ea"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a288af208cb43c6bdd67b788dc92037ea">begin</a> () const</td></tr>
<tr class="memdesc:a288af208cb43c6bdd67b788dc92037ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the first item in the sketch.  <br /></td></tr>
<tr class="separator:a288af208cb43c6bdd67b788dc92037ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5194060fd9b11a856cfb47e59801a3eb" id="r_a5194060fd9b11a856cfb47e59801a3eb"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a5194060fd9b11a856cfb47e59801a3eb">end</a> () const</td></tr>
<tr class="memdesc:a5194060fd9b11a856cfb47e59801a3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the past-the-end item in the sketch.  <br /></td></tr>
<tr class="separator:a5194060fd9b11a856cfb47e59801a3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9c9c240dd591017fd6a80e147b7c00" id="r_a0a9c9c240dd591017fd6a80e147b7c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, C, A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a0a9c9c240dd591017fd6a80e147b7c00">get_sorted_view</a> () const</td></tr>
<tr class="memdesc:a0a9c9c240dd591017fd6a80e147b7c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sorted view of this sketch.  <br /></td></tr>
<tr class="separator:a0a9c9c240dd591017fd6a80e147b7c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adb2232570b4977756cddd02b4b6b845b" id="r_adb2232570b4977756cddd02b4b6b845b"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename std::enable_if&lt; std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:adb2232570b4977756cddd02b4b6b845b"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#adb2232570b4977756cddd02b4b6b845b">get_max_serialized_size_bytes</a> (uint16_t k, uint64_t n)</td></tr>
<tr class="memdesc:adb2232570b4977756cddd02b4b6b845b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns upper bound on the serialized size of a sketch given a parameter <em>k</em> and stream length.  <br /></td></tr>
<tr class="separator:adb2232570b4977756cddd02b4b6b845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cd0e67339d17d0b48f6f43bc26d381" id="r_a02cd0e67339d17d0b48f6f43bc26d381"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a02cd0e67339d17d0b48f6f43bc26d381"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a02cd0e67339d17d0b48f6f43bc26d381">get_max_serialized_size_bytes</a> (uint16_t k, uint64_t n, size_t max_item_size_bytes)</td></tr>
<tr class="memdesc:a02cd0e67339d17d0b48f6f43bc26d381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns upper bound on the serialized size of a sketch given a parameter <em>k</em> and stream length.  <br /></td></tr>
<tr class="separator:a02cd0e67339d17d0b48f6f43bc26d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2a0c95cd2c88854ec9b9ab7088f419" id="r_a3f2a0c95cd2c88854ec9b9ab7088f419"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3f2a0c95cd2c88854ec9b9ab7088f419"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#a3f2a0c95cd2c88854ec9b9ab7088f419">deserialize</a> (std::istream &amp;is, const SerDe &amp;sd=SerDe(), const C &amp;comparator=C(), const A &amp;allocator=A())</td></tr>
<tr class="memdesc:a3f2a0c95cd2c88854ec9b9ab7088f419"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method deserializes a sketch from a given stream.  <br /></td></tr>
<tr class="separator:a3f2a0c95cd2c88854ec9b9ab7088f419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7e72ffdee78a8f96d8160a154d81a" id="r_afdd7e72ffdee78a8f96d8160a154d81a"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:afdd7e72ffdee78a8f96d8160a154d81a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1kll__sketch.html#afdd7e72ffdee78a8f96d8160a154d81a">deserialize</a> (const void *bytes, size_t size, const SerDe &amp;sd=SerDe(), const C &amp;comparator=C(), const A &amp;allocator=A())</td></tr>
<tr class="memdesc:afdd7e72ffdee78a8f96d8160a154d81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method deserializes a sketch from a given array of bytes.  <br /></td></tr>
<tr class="separator:afdd7e72ffdee78a8f96d8160a154d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename C = std::less&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt;<br />
class datasketches::kll_sketch&lt; T, C, A &gt;</div><p>Implementation of a very compact quantiles sketch with lazy compaction scheme and nearly optimal accuracy per retained item. </p>
<p>See <a href="https://arxiv.org/abs/1603.05346v2">Optimal Quantile Approximation in Streams</a>.</p>
<p>This is a stochastic streaming sketch that enables near real-time analysis of the approximate distribution of items from a very large stream in a single pass, requiring only that the items are comparable. The analysis is obtained using <em><a class="el" href="classdatasketches_1_1kll__sketch.html#ac02fcfb6e706148458a2ef89390223a9" title="Returns an item from the sketch that is the best approximation to an item from the original stream wi...">get_quantile()</a></em> function or the inverse functions <a class="el" href="classdatasketches_1_1kll__sketch.html#a849dfa06c183fd2fdfe4fe4a7e29d918" title="Returns an approximation to the normalized rank of the given item from 0 to 1, inclusive.">get_rank()</a>, <a class="el" href="classdatasketches_1_1kll__sketch.html#a44226b755e73883ea2c128876e35b1d1" title="Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of sp...">get_PMF()</a> (Probability Mass Function), and <a class="el" href="classdatasketches_1_1kll__sketch.html#a20a4d992209b2aa58614c998d143705c" title="Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analo...">get_CDF()</a> (Cumulative Distribution Function).</p>
<p>As of May 2020, this implementation produces serialized sketches which are binary-compatible with the equivalent Java implementation only when template parameter T = float (32-bit single precision values).</p>
<p>Given an input stream of <em>N</em> items, the <em>natural rank</em> of any specific item is defined as its index <em>(1 to N)</em> in inclusive mode or <em>(0 to N-1)</em> in exclusive mode in the hypothetical sorted stream of all <em>N</em> input items.</p>
<p>The <em>normalized rank</em> (<em>rank</em>) of any specific item is defined as its <em>natural rank</em> divided by <em>N</em>. Thus, the <em>normalized rank</em> is between zero and one. In the documentation for this sketch <em>natural rank</em> is never used so any reference to just <em>rank</em> should be interpreted to mean <em>normalized rank</em>.</p>
<p>This sketch is configured with a parameter <em>k</em>, which affects the size of the sketch and its estimation error.</p>
<p>The estimation error is commonly called <em>epsilon</em> (or <em>eps</em>) and is a fraction between zero and one. Larger values of <em>k</em> result in smaller values of epsilon. Epsilon is always with respect to the rank and cannot be applied to the corresponding items.</p>
<p>The relationship between the normalized rank and the corresponding items can be viewed as a two dimensional monotonic plot with the normalized rank on one axis and the corresponding items on the other axis. If the y-axis is specified as the item-axis and the x-axis as the normalized rank, then <em>y = get_quantile(x)</em> is a monotonically increasing function.</p>
<p>The function <em>get_quantile(rank)</em> translates ranks into corresponding quantiles. The functions <em>get_rank(item), get_CDF(...) (Cumulative Distribution Function), and get_PMF(...) (Probability Mass Function)</em> perform the opposite operation and translate items into ranks.</p>
<p>The <em>getPMF(...)</em> function has about 13 to 47% worse rank error (depending on <em>k</em>) than the other queries because the mass of each "bin" of the PMF has "double-sided" error from the upper and lower edges of the bin as a result of a subtraction, as the errors from the two edges can sometimes add.</p>
<p>The default <em>k</em> of 200 yields a "single-sided" epsilon of about 1.33% and a "double-sided" (PMF) epsilon of about 1.65%.</p>
<p>A <em>get_quantile(rank)</em> query has the following guarantees: </p><ul>
<li>
Let <em>q = get_quantile(r)</em> where <em>r</em> is the rank between zero and one. </li>
<li>
The quantile <em>q</em> will be an item from the input stream. </li>
<li>
Let <em>trueRank</em> be the true rank of <em>q</em> derived from the hypothetical sorted stream of all <em>N</em> items. </li>
<li>
Let <em>eps = get_normalized_rank_error(false)</em>. </li>
<li>
Then <em>r - eps &le; trueRank &le; r + eps</em> with a confidence of 99%. Note that the error is on the rank, not the quantile. </li>
</ul>
<p>A <em>get_rank(item)</em> query has the following guarantees: </p><ul>
<li>
Let <em>r = get_rank(i)</em> where <em>i</em> is an item between the min and max items of the input stream. </li>
<li>
Let <em>true_rank</em> be the true rank of <em>i</em> derived from the hypothetical sorted stream of all <em>N</em> items. </li>
<li>
Let <em>eps = get_normalized_rank_error(false)</em>. </li>
<li>
Then <em>r - eps &le; trueRank &le; r + eps</em> with a confidence of 99%. </li>
</ul>
<p>A <em><a class="el" href="classdatasketches_1_1kll__sketch.html#a44226b755e73883ea2c128876e35b1d1" title="Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of sp...">get_PMF()</a></em> query has the following guarantees: </p><ul>
<li>
Let <em>{r1, r2, ..., r(m+1)} = get_PMF(s1, s2, ..., sm)</em> where <em>s1, s2</em> are split points (items from the input domain) between the min and max items of the input stream. </li>
<li>
Let <em>mass<sub>i</sub> = estimated mass between s<sub>i</sub> and s<sub>i+1</sub></em>. </li>
<li>
Let <em>trueMass</em> be the true mass between the items of <em>s<sub>i</sub>, s<sub>i+1</sub></em> derived from the hypothetical sorted stream of all <em>N</em> items. </li>
<li>
Let <em>eps = get_normalized_rank_error(true)</em>. </li>
<li>
then <em>mass - eps &le; trueMass &le; mass + eps</em> with a confidence of 99%. </li>
<li>
r(m+1) includes the mass of all points larger than sm. </li>
</ul>
<p>A <em>get_CDF(...)</em> query has the following guarantees; </p><ul>
<li>
Let <em>{r1, r2, ..., r(m+1)} = get_CDF(s1, s2, ..., sm)</em> where <em>s1, s2, ...</em> are split points (items from the input domain) between the min and max items of the input stream. </li>
<li>
Let <em>mass<sub>i</sub> = r<sub>i+1</sub> - r<sub>i</sub></em>. </li>
<li>
Let <em>trueMass</em> be the true mass between the true ranks of <em>s<sub>i</sub>, s<sub>i+1</sub></em> derived from the hypothetical sorted stream of all <em>N</em> items. </li>
<li>
Let <em>eps = get_normalized_rank_error(true)</em>. </li>
<li>
then <em>mass - eps &le; trueMass &le; mass + eps</em> with a confidence of 99%. </li>
<li>
1 - r(m+1) includes the mass of all points larger than sm. </li>
</ul>
<p>From the above, it might seem like we could make some estimates to bound the <em>item</em> returned from a call to <em><a class="el" href="classdatasketches_1_1kll__sketch.html#ac02fcfb6e706148458a2ef89390223a9" title="Returns an item from the sketch that is the best approximation to an item from the original stream wi...">get_quantile()</a></em>. The sketch, however, does not let us derive error bounds or confidences around items. Because errors are independent, we can approximately bracket a value as shown below, but there are no error estimates available. Additionally, the interval may be quite large for certain distributions. </p><ul>
<li>
Let <em>q = get_quantile(r)</em>, the estimated quantile of rank <em>r</em>. </li>
<li>
Let <em>eps = get_normalized_rank_error(false)</em>. </li>
<li>
Let <em>q<sub>lo</sub></em> = estimated quantile of rank <em>(r - eps)</em>. </li>
<li>
Let <em>q<sub>hi</sub></em> = estimated quantile of rank <em>(r + eps)</em>. </li>
<li>
Then <em>q<sub>lo</sub> &le; q &le; q<sub>hi</sub></em>, with 99% confidence. </li>
</ul>
<p>author Kevin Lang author Alexander Saydakov author Lee Rhodes </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa796209b1ef5dc41e83ed8158f77d280" name="aa796209b1ef5dc41e83ed8158f77d280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa796209b1ef5dc41e83ed8158f77d280">&#9670;&#160;</a></span>quantile_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = std::less&lt;T&gt;, typename A  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdatasketches_1_1kll__sketch.html#aa796209b1ef5dc41e83ed8158f77d280">quantile_return_type</a> =  typename <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt;T, C, A&gt;::quantile_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantile return type. </p>
<p>This is to return quantiles either by value (for arithmetic types) or by const reference (for all other types) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afca1c904b4598d7a9548a40a802ed2b4" name="afca1c904b4598d7a9548a40a802ed2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca1c904b4598d7a9548a40a802ed2b4">&#9670;&#160;</a></span>kll_sketch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="namespacedatasketches_1_1kll__constants.html#ac8602cb1bd28fc26ae74b484e81a9a52">kll_constants::DEFAULT_K</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>C()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>A()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>affects the size of the sketch and its estimation error </td></tr>
    <tr><td class="paramname">comparator</td><td>strict weak ordering function (see C++ named requirements: Compare) </td></tr>
    <tr><td class="paramname">allocator</td><td>used by this sketch to allocate memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7352580134284b937cb2510d192434e" name="af7352580134284b937cb2510d192434e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7352580134284b937cb2510d192434e">&#9670;&#160;</a></span>kll_sketch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd53c0366552f3211d54e4746e12f1fe" name="acd53c0366552f3211d54e4746e12f1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd53c0366552f3211d54e4746e12f1fe">&#9670;&#160;</a></span>kll_sketch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d934088182b8615c2fa34a4716d7d44" name="a0d934088182b8615c2fa34a4716d7d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d934088182b8615c2fa34a4716d7d44">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this sketch </dd></dl>

</div>
</div>
<a id="a3b0bad718ea491dd8176196d4b250ff4" name="a3b0bad718ea491dd8176196d4b250ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0bad718ea491dd8176196d4b250ff4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this sketch </dd></dl>

</div>
</div>
<a id="a5200c74c52ee0f76d0d34c1ca6aec65c" name="a5200c74c52ee0f76d0d34c1ca6aec65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200c74c52ee0f76d0d34c1ca6aec65c">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename FwdT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void update </td>
          <td>(</td>
          <td class="paramtype">FwdT &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates this sketch with the given data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>from a stream of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49bb19e78f36fb72b8496cd6cff71fec" name="a49bb19e78f36fb72b8496cd6cff71fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bb19e78f36fb72b8496cd6cff71fec">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename FwdSk &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype">FwdSk &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges another sketch into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to merge into this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a2b7a58dc85678d08752945ff655362" name="a5a2b7a58dc85678d08752945ff655362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2b7a58dc85678d08752945ff655362">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this sketch is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>empty flag </dd></dl>

</div>
</div>
<a id="a59f4c39b9f2e762e8e3445ef89e1d264" name="a59f4c39b9f2e762e8e3445ef89e1d264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f4c39b9f2e762e8e3445ef89e1d264">&#9670;&#160;</a></span>get_k()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_k </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns configured parameter k. </p>
<dl class="section return"><dt>Returns</dt><dd>parameter k </dd></dl>

</div>
</div>
<a id="af857be9469a7565252626f27e1f9d74d" name="af857be9469a7565252626f27e1f9d74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af857be9469a7565252626f27e1f9d74d">&#9670;&#160;</a></span>get_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the input stream. </p>
<dl class="section return"><dt>Returns</dt><dd>stream length </dd></dl>

</div>
</div>
<a id="a31fa76458d81a17dbebfcb828e531f14" name="a31fa76458d81a17dbebfcb828e531f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fa76458d81a17dbebfcb828e531f14">&#9670;&#160;</a></span>get_num_retained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_num_retained </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of retained items (samples) in the sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of retained items </dd></dl>

</div>
</div>
<a id="ae95a04b1d7dccb3d9b3f3c3d087aa8e6" name="ae95a04b1d7dccb3d9b3f3c3d087aa8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95a04b1d7dccb3d9b3f3c3d087aa8e6">&#9670;&#160;</a></span>is_estimation_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_estimation_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this sketch is in estimation mode. </p>
<dl class="section return"><dt>Returns</dt><dd>estimation mode flag </dd></dl>

</div>
</div>
<a id="aa3f3769ba3fae6fa0e8a0bd65fef5422" name="aa3f3769ba3fae6fa0e8a0bd65fef5422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f3769ba3fae6fa0e8a0bd65fef5422">&#9670;&#160;</a></span>get_min_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_min_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the min item of the stream. </p>
<p>If the sketch is empty this throws std::runtime_error. </p><dl class="section return"><dt>Returns</dt><dd>the min item of the stream </dd></dl>

</div>
</div>
<a id="a4cdb10e4f2949d55d29421c6e381a300" name="a4cdb10e4f2949d55d29421c6e381a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdb10e4f2949d55d29421c6e381a300">&#9670;&#160;</a></span>get_max_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_max_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max item of the stream. </p>
<p>If the sketch is empty this throws std::runtime_error. </p><dl class="section return"><dt>Returns</dt><dd>the max item of the stream </dd></dl>

</div>
</div>
<a id="a076f89979daa6471a3868cb97ea99b40" name="a076f89979daa6471a3868cb97ea99b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076f89979daa6471a3868cb97ea99b40">&#9670;&#160;</a></span>get_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C get_comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of the comparator for this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>comparator </dd></dl>

</div>
</div>
<a id="a9d85cf47c4ecd0580ec623c42006dd1b" name="a9d85cf47c4ecd0580ec623c42006dd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d85cf47c4ecd0580ec623c42006dd1b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of the allocator for this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>allocator </dd></dl>

</div>
</div>
<a id="ac02fcfb6e706148458a2ef89390223a9" name="ac02fcfb6e706148458a2ef89390223a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02fcfb6e706148458a2ef89390223a9">&#9670;&#160;</a></span>get_quantile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an item from the sketch that is the best approximation to an item from the original stream with the given rank. </p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>of an item in the hypothetical sorted stream. </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true, the given rank is considered inclusive (includes weight of an item)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>approximate quantile associated with the given rank </dd></dl>

</div>
</div>
<a id="a849dfa06c183fd2fdfe4fe4a7e29d918" name="a849dfa06c183fd2fdfe4fe4a7e29d918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849dfa06c183fd2fdfe4fe4a7e29d918">&#9670;&#160;</a></span>get_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double get_rank </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the normalized rank of the given item from 0 to 1, inclusive. </p>
<p>The resulting approximation has a probabilistic guarantee that can be obtained from the get_normalized_rank_error(false) function.</p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>to be ranked. </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the weight of the given item is included into the rank. Otherwise the rank equals the sum of the weights of all items that are less than the given item according to the comparator C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an approximate rank of the given item </dd></dl>

</div>
</div>
<a id="a44226b755e73883ea2c128876e35b1d1" name="a44226b755e73883ea2c128876e35b1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44226b755e73883ea2c128876e35b1d1">&#9670;&#160;</a></span>get_PMF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_PMF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items). </p>
<p>The resulting approximations have a probabilistic guarantee that can be obtained from the get_normalized_rank_error(true) function.</p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals (bins).</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in PMF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles each of which is an approximation to the fraction of the input stream items (the mass) that fall into one of those intervals. </dd></dl>

</div>
</div>
<a id="a20a4d992209b2aa58614c998d143705c" name="a20a4d992209b2aa58614c998d143705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4d992209b2aa58614c998d143705c">&#9670;&#160;</a></span>get_CDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_CDF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items). </p>
<p>The resulting approximations have a probabilistic guarantee that can be obtained from the get_normalized_rank_error(false) function.</p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals.</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in CDF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles, which are a consecutive approximation to the CDF of the input stream given the split_points. The value at array position j of the returned CDF array is the sum of the returned values in positions 0 through j of the returned PMF array. This can be viewed as array of ranks of the given split points plus one more value that is always 1. </dd></dl>

</div>
</div>
<a id="ae08ba9502b0403ad4448d649ce29b850" name="ae08ba9502b0403ad4448d649ce29b850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08ba9502b0403ad4448d649ce29b850">&#9670;&#160;</a></span>get_normalized_rank_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double get_normalized_rank_error </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pmf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the approximate rank error of this sketch normalized as a fraction between zero and one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmf</td><td>if true, returns the "double-sided" normalized rank error for the <a class="el" href="classdatasketches_1_1kll__sketch.html#a44226b755e73883ea2c128876e35b1d1" title="Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of sp...">get_PMF()</a> function. Otherwise, it is the "single-sided" normalized rank error for all the other queries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if pmf is true, returns the normalized rank error for the <a class="el" href="classdatasketches_1_1kll__sketch.html#a44226b755e73883ea2c128876e35b1d1" title="Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of sp...">get_PMF()</a> function. Otherwise, it is the "single-sided" normalized rank error for all the other queries. </dd></dl>

</div>
</div>
<a id="ad9a5259d93d148b5c2050d68e7788716" name="ad9a5259d93d148b5c2050d68e7788716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a5259d93d148b5c2050d68e7788716">&#9670;&#160;</a></span>get_serialized_size_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename TT , typename SerDe , typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t get_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes size needed to serialize the current state of the sketch. </p>
<p>This version is for fixed-size arithmetic types (integral and floating point). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes needed to serialize this sketch </dd></dl>

</div>
</div>
<a id="ad9a5259d93d148b5c2050d68e7788716" name="ad9a5259d93d148b5c2050d68e7788716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a5259d93d148b5c2050d68e7788716">&#9670;&#160;</a></span>get_serialized_size_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = std::less&lt;T&gt;, typename A  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t get_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes size needed to serialize the current state of the sketch. </p>
<p>This version is for all other types and can be expensive since every item needs to be looked at. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes needed to serialize this sketch </dd></dl>

</div>
</div>
<a id="adb2232570b4977756cddd02b4b6b845b" name="adb2232570b4977756cddd02b4b6b845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2232570b4977756cddd02b4b6b845b">&#9670;&#160;</a></span>get_max_serialized_size_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename TT , typename std::enable_if&lt; std::is_arithmetic&lt; TT &gt;::value, int &gt;::type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_max_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns upper bound on the serialized size of a sketch given a parameter <em>k</em> and stream length. </p>
<p>The resulting size is an overestimate to make sure actual sketches don't exceed it. This method can be used if allocation of storage is necessary beforehand, but it is not optimal. This method is for arithmetic types (integral and floating point) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>parameter that controls size of the sketch and accuracy of estimates </td></tr>
    <tr><td class="paramname">n</td><td>stream length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound on the serialized size </dd></dl>

</div>
</div>
<a id="a02cd0e67339d17d0b48f6f43bc26d381" name="a02cd0e67339d17d0b48f6f43bc26d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cd0e67339d17d0b48f6f43bc26d381">&#9670;&#160;</a></span>get_max_serialized_size_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename TT , typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_max_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_item_size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns upper bound on the serialized size of a sketch given a parameter <em>k</em> and stream length. </p>
<p>The resulting size is an overestimate to make sure actual sketches don't exceed it. This method can be used if allocation of storage is necessary beforehand, but it is not optimal. This method is for all other non-arithmetic types, and it takes a max size of an item as input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>parameter that controls size of the sketch and accuracy of estimates </td></tr>
    <tr><td class="paramname">n</td><td>stream length </td></tr>
    <tr><td class="paramname">max_item_size_bytes</td><td>maximum size of an item in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound on the serialized size </dd></dl>

</div>
</div>
<a id="a538940c100e4353b3671ad452d3d3056" name="a538940c100e4353b3671ad452d3d3056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538940c100e4353b3671ad452d3d3056">&#9670;&#160;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename SerDe &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method serializes the sketch into a given stream in a binary form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0c269c23926e93b1c7a9c00e86af97" name="a1d0c269c23926e93b1c7a9c00e86af97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c269c23926e93b1c7a9c00e86af97">&#9670;&#160;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = std::less&lt;T&gt;, typename A  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_bytes serialize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>header_size_bytes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method serializes the sketch as a vector of bytes. </p>
<p>An optional header can be reserved in front of the sketch. It is a blank space of a given size. This header is used in Datasketches PostgreSQL extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_size_bytes</td><td>space to reserve in front of the sketch </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>serialized sketch as a vector of bytes </dd></dl>

</div>
</div>
<a id="a3f2a0c95cd2c88854ec9b9ab7088f419" name="a3f2a0c95cd2c88854ec9b9ab7088f419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2a0c95cd2c88854ec9b9ab7088f419">&#9670;&#160;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = std::less&lt;T&gt;, typename A  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>C()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>A()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method deserializes a sketch from a given stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
    <tr><td class="paramname">comparator</td><td>instance of a Comparator </td></tr>
    <tr><td class="paramname">allocator</td><td>instance of an Allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a sketch </dd></dl>

</div>
</div>
<a id="afdd7e72ffdee78a8f96d8160a154d81a" name="afdd7e72ffdee78a8f96d8160a154d81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd7e72ffdee78a8f96d8160a154d81a">&#9670;&#160;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = std::less&lt;T&gt;, typename A  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a> deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>C()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>A()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method deserializes a sketch from a given array of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>pointer to the array of bytes </td></tr>
    <tr><td class="paramname">size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
    <tr><td class="paramname">comparator</td><td>instance of a Comparator </td></tr>
    <tr><td class="paramname">allocator</td><td>instance of an Allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a sketch </dd></dl>

</div>
</div>
<a id="a592a7af55659ff803b26a45552a68dda" name="a592a7af55659ff803b26a45552a68dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a7af55659ff803b26a45552a68dda">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">string&lt; A &gt; to_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_levels</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_items</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a summary of the sketch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_levels</td><td>if true include information about levels </td></tr>
    <tr><td class="paramname">print_items</td><td>if true include sketch data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288af208cb43c6bdd67b788dc92037ea" name="a288af208cb43c6bdd67b788dc92037ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288af208cb43c6bdd67b788dc92037ea">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt;::const_iterator begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the first item in the sketch. </p>
<p>If the sketch is empty, the returned iterator must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first item in the sketch </dd></dl>

</div>
</div>
<a id="a5194060fd9b11a856cfb47e59801a3eb" name="a5194060fd9b11a856cfb47e59801a3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5194060fd9b11a856cfb47e59801a3eb">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1kll__sketch.html">kll_sketch</a>&lt; T, C, A &gt;::const_iterator end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the past-the-end item in the sketch. </p>
<p>The past-the-end item is the hypothetical item that would follow the last item. It does not point to any item, and must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the past-the-end item in the sketch </dd></dl>

</div>
</div>
<a id="a0a9c9c240dd591017fd6a80e147b7c00" name="a0a9c9c240dd591017fd6a80e147b7c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9c9c240dd591017fd6a80e147b7c00">&#9670;&#160;</a></span>get_sorted_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, C, A &gt; get_sorted_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sorted view of this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>the sorted view of this sketch </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>kll/include/<a class="el" href="kll__sketch_8hpp_source.html">kll_sketch.hpp</a></li>
<li>kll/include/<a class="el" href="kll__sketch__impl_8hpp_source.html">kll_sketch_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
