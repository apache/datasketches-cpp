<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>datasketches-cpp: quantiles_sorted_view&lt; T, Comparator, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">datasketches-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedatasketches.html">datasketches</a></li><li class="navelem"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdatasketches_1_1quantiles__sorted__view-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">quantiles_sorted_view&lt; T, Comparator, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sorted view for quantiles sketches (REQ, KLL and Quantiles)  
 <a href="classdatasketches_1_1quantiles__sorted__view.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="quantiles__sorted__view_8hpp_source.html">quantiles_sorted_view.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae30af6850c2fd8b7d84bd14d51ec1d74"><td class="memItemLeft" align="right" valign="top"><a id="ae30af6850c2fd8b7d84bd14d51ec1d74"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#ae30af6850c2fd8b7d84bd14d51ec1d74">Entry</a> = typename std::conditional&lt; std::is_arithmetic&lt; T &gt;::value, std::pair&lt; T, uint64_t &gt;, std::pair&lt; const T *, uint64_t &gt; &gt;::type</td></tr>
<tr class="memdesc:ae30af6850c2fd8b7d84bd14d51ec1d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry type. <br /></td></tr>
<tr class="separator:ae30af6850c2fd8b7d84bd14d51ec1d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4905c4f3ebeb14de4e7a2f5d92832"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a5ab4905c4f3ebeb14de4e7a2f5d92832">quantile_return_type</a> = typename std::conditional&lt; std::is_arithmetic&lt; T &gt;::value, T, const T &amp; &gt;::type</td></tr>
<tr class="memdesc:a5ab4905c4f3ebeb14de4e7a2f5d92832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantile return type.  <a href="classdatasketches_1_1quantiles__sorted__view.html#a5ab4905c4f3ebeb14de4e7a2f5d92832">More...</a><br /></td></tr>
<tr class="separator:a5ab4905c4f3ebeb14de4e7a2f5d92832"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5c959a538216a09ab28c5283585956c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#ad5c959a538216a09ab28c5283585956c">begin</a> () const</td></tr>
<tr class="memdesc:ad5c959a538216a09ab28c5283585956c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the first entry in the view.  <a href="classdatasketches_1_1quantiles__sorted__view.html#ad5c959a538216a09ab28c5283585956c">More...</a><br /></td></tr>
<tr class="separator:ad5c959a538216a09ab28c5283585956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e60e117300685401961e36f196f7a"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#ae11e60e117300685401961e36f196f7a">end</a> () const</td></tr>
<tr class="memdesc:ae11e60e117300685401961e36f196f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the past-the-end entry in the view.  <a href="classdatasketches_1_1quantiles__sorted__view.html#ae11e60e117300685401961e36f196f7a">More...</a><br /></td></tr>
<tr class="separator:ae11e60e117300685401961e36f196f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb5a711406a8c3e5d937eb9350cca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a259cb5a711406a8c3e5d937eb9350cca">size</a> () const</td></tr>
<tr class="separator:a259cb5a711406a8c3e5d937eb9350cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a849dfa06c183fd2fdfe4fe4a7e29d918">get_rank</a> (const T &amp;item, bool inclusive=true) const</td></tr>
<tr class="memdesc:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the normalized rank of the given item.  <a href="classdatasketches_1_1quantiles__sorted__view.html#a849dfa06c183fd2fdfe4fe4a7e29d918">More...</a><br /></td></tr>
<tr class="separator:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02fcfb6e706148458a2ef89390223a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a5ab4905c4f3ebeb14de4e7a2f5d92832">quantile_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#ac02fcfb6e706148458a2ef89390223a9">get_quantile</a> (double rank, bool inclusive=true) const</td></tr>
<tr class="memdesc:ac02fcfb6e706148458a2ef89390223a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an item from the sketch that is the best approximation to an item from the original stream with the given normalized rank.  <a href="classdatasketches_1_1quantiles__sorted__view.html#ac02fcfb6e706148458a2ef89390223a9">More...</a><br /></td></tr>
<tr class="separator:ac02fcfb6e706148458a2ef89390223a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4d992209b2aa58614c998d143705c"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a20a4d992209b2aa58614c998d143705c">get_CDF</a> (const T *split_points, uint32_t <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a259cb5a711406a8c3e5d937eb9350cca">size</a>, bool inclusive=true) const</td></tr>
<tr class="memdesc:a20a4d992209b2aa58614c998d143705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items).  <a href="classdatasketches_1_1quantiles__sorted__view.html#a20a4d992209b2aa58614c998d143705c">More...</a><br /></td></tr>
<tr class="separator:a20a4d992209b2aa58614c998d143705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44226b755e73883ea2c128876e35b1d1"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a44226b755e73883ea2c128876e35b1d1">get_PMF</a> (const T *split_points, uint32_t <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a259cb5a711406a8c3e5d937eb9350cca">size</a>, bool inclusive=true) const</td></tr>
<tr class="memdesc:a44226b755e73883ea2c128876e35b1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items).  <a href="classdatasketches_1_1quantiles__sorted__view.html#a44226b755e73883ea2c128876e35b1d1">More...</a><br /></td></tr>
<tr class="separator:a44226b755e73883ea2c128876e35b1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Comparator, typename Allocator&gt;<br />
class datasketches::quantiles_sorted_view&lt; T, Comparator, Allocator &gt;</h3>

<p>Sorted view for quantiles sketches (REQ, KLL and Quantiles) </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ab4905c4f3ebeb14de4e7a2f5d92832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab4905c4f3ebeb14de4e7a2f5d92832">&#9670;&nbsp;</a></span>quantile_return_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html#a5ab4905c4f3ebeb14de4e7a2f5d92832">quantile_return_type</a> =  typename std::conditional&lt;std::is_arithmetic&lt;T&gt;::value, T, const T&amp;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantile return type. </p>
<p>This is to return quantiles either by value (for arithmetic types) or by const reference (for all other types) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5c959a538216a09ab28c5283585956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c959a538216a09ab28c5283585956c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the first entry in the view. </p>
<p>If the view is empty, the returned iterator must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first entry </dd></dl>

</div>
</div>
<a id="ae11e60e117300685401961e36f196f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e60e117300685401961e36f196f7a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the past-the-end entry in the view. </p>
<p>The past-the-end entry is the hypothetical entry that would follow the last entry. It does not point to any entry, and must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the past-the-end entry </dd></dl>

</div>
</div>
<a id="a259cb5a711406a8c3e5d937eb9350cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb5a711406a8c3e5d937eb9350cca">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t size</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>size of the view </dd></dl>

</div>
</div>
<a id="a849dfa06c183fd2fdfe4fe4a7e29d918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849dfa06c183fd2fdfe4fe4a7e29d918">&#9670;&nbsp;</a></span>get_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_rank </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the normalized rank of the given item. </p>
<p>If the view is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>to be ranked </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the weight of the given item is included into the rank. Otherwise the rank equals the sum of the weights of all items that are less than the given item according to the Comparator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an approximate normalized rank of the given item (0 to 1 inclusive) </dd></dl>

</div>
</div>
<a id="ac02fcfb6e706148458a2ef89390223a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02fcfb6e706148458a2ef89390223a9">&#9670;&nbsp;</a></span>get_quantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an item from the sketch that is the best approximation to an item from the original stream with the given normalized rank. </p>
<p>If the view is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>of an item in the hypothetical sorted stream. </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true, the given rank is considered inclusive (includes weight of an item)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>approximate quantile associated with the given normalized rank </dd></dl>

</div>
</div>
<a id="a20a4d992209b2aa58614c998d143705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4d992209b2aa58614c998d143705c">&#9670;&nbsp;</a></span>get_CDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_CDF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items). </p>
<p>If the view is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals.</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in CDF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles, which are a consecutive approximation to the CDF of the input stream given the split_points. The value at array position j of the returned CDF array is the sum of the returned values in positions 0 through j of the returned PMF array. This can be viewed as array of ranks of the given split points plus one more value that is always 1. </dd></dl>

</div>
</div>
<a id="a44226b755e73883ea2c128876e35b1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44226b755e73883ea2c128876e35b1d1">&#9670;&nbsp;</a></span>get_PMF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_PMF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items). </p>
<p>If the view is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals (bins).</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in PMF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles each of which is an approximation to the fraction of the input stream items (the mass) that fall into one of those intervals. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>common/include/<a class="el" href="quantiles__sorted__view_8hpp_source.html">quantiles_sorted_view.hpp</a></li>
<li>common/include/<a class="el" href="quantiles__sorted__view__impl_8hpp_source.html">quantiles_sorted_view_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
