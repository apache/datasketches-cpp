<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>datasketches-cpp: req_sketch&lt; T, Comparator, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">datasketches-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedatasketches.html">datasketches</a></li><li class="navelem"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdatasketches_1_1req__sketch-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">req_sketch&lt; T, Comparator, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Relative Error Quantiles Sketch.  
 <a href="classdatasketches_1_1req__sketch.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="req__sketch_8hpp_source.html">req_sketch.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c80d2361c940f99df9f850615c2dcbe" id="r_a4c80d2361c940f99df9f850615c2dcbe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a4c80d2361c940f99df9f850615c2dcbe">quantile_return_type</a> = typename <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, Comparator, Allocator &gt;::quantile_return_type</td></tr>
<tr class="memdesc:a4c80d2361c940f99df9f850615c2dcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantile return type.  <br /></td></tr>
<tr class="separator:a4c80d2361c940f99df9f850615c2dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a732d80ecaa19aab05f65ca62bdf0452c" id="r_a732d80ecaa19aab05f65ca62bdf0452c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a732d80ecaa19aab05f65ca62bdf0452c">req_sketch</a> (uint16_t k, bool hra=true, const Comparator &amp;comparator=Comparator(), const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="memdesc:a732d80ecaa19aab05f65ca62bdf0452c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a732d80ecaa19aab05f65ca62bdf0452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec3122d5c0994c725123257065de56b" id="r_a4ec3122d5c0994c725123257065de56b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a4ec3122d5c0994c725123257065de56b">req_sketch</a> (const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;other)</td></tr>
<tr class="memdesc:a4ec3122d5c0994c725123257065de56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4ec3122d5c0994c725123257065de56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0fc41e0544761ffc626aa70415319" id="r_a25d0fc41e0544761ffc626aa70415319"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a25d0fc41e0544761ffc626aa70415319">req_sketch</a> (<a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a25d0fc41e0544761ffc626aa70415319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a25d0fc41e0544761ffc626aa70415319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e85db46b1d76086d5e9b5065b74a46" id="r_ab6e85db46b1d76086d5e9b5065b74a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ab6e85db46b1d76086d5e9b5065b74a46">operator=</a> (const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;other)</td></tr>
<tr class="memdesc:ab6e85db46b1d76086d5e9b5065b74a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <br /></td></tr>
<tr class="separator:ab6e85db46b1d76086d5e9b5065b74a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36e220c05c86824c475a779e2c39232" id="r_ac36e220c05c86824c475a779e2c39232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ac36e220c05c86824c475a779e2c39232">operator=</a> (<a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ac36e220c05c86824c475a779e2c39232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="separator:ac36e220c05c86824c475a779e2c39232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1943668612ea073d2f6381ee8c2ddfbd" id="r_a1943668612ea073d2f6381ee8c2ddfbd"><td class="memTemplParams" colspan="2">template&lt;typename TT , typename CC , typename AA &gt; </td></tr>
<tr class="memitem:a1943668612ea073d2f6381ee8c2ddfbd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a1943668612ea073d2f6381ee8c2ddfbd">req_sketch</a> (const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; TT, CC, AA &gt; &amp;other, const Comparator &amp;comparator=Comparator(), const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="memdesc:a1943668612ea073d2f6381ee8c2ddfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type converting constructor.  <br /></td></tr>
<tr class="separator:a1943668612ea073d2f6381ee8c2ddfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f4c39b9f2e762e8e3445ef89e1d264" id="r_a59f4c39b9f2e762e8e3445ef89e1d264"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a59f4c39b9f2e762e8e3445ef89e1d264">get_k</a> () const</td></tr>
<tr class="memdesc:a59f4c39b9f2e762e8e3445ef89e1d264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns configured parameter K.  <br /></td></tr>
<tr class="separator:a59f4c39b9f2e762e8e3445ef89e1d264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6177b85206272c56ee75747bb885735" id="r_af6177b85206272c56ee75747bb885735"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#af6177b85206272c56ee75747bb885735">is_HRA</a> () const</td></tr>
<tr class="memdesc:af6177b85206272c56ee75747bb885735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns configured parameter High Rank Accuracy.  <br /></td></tr>
<tr class="separator:af6177b85206272c56ee75747bb885735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b7a58dc85678d08752945ff655362" id="r_a5a2b7a58dc85678d08752945ff655362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a5a2b7a58dc85678d08752945ff655362">is_empty</a> () const</td></tr>
<tr class="memdesc:a5a2b7a58dc85678d08752945ff655362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this sketch is empty.  <br /></td></tr>
<tr class="separator:a5a2b7a58dc85678d08752945ff655362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af857be9469a7565252626f27e1f9d74d" id="r_af857be9469a7565252626f27e1f9d74d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#af857be9469a7565252626f27e1f9d74d">get_n</a> () const</td></tr>
<tr class="memdesc:af857be9469a7565252626f27e1f9d74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the input stream.  <br /></td></tr>
<tr class="separator:af857be9469a7565252626f27e1f9d74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa76458d81a17dbebfcb828e531f14" id="r_a31fa76458d81a17dbebfcb828e531f14"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a31fa76458d81a17dbebfcb828e531f14">get_num_retained</a> () const</td></tr>
<tr class="memdesc:a31fa76458d81a17dbebfcb828e531f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of retained items in the sketch.  <br /></td></tr>
<tr class="separator:a31fa76458d81a17dbebfcb828e531f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a04b1d7dccb3d9b3f3c3d087aa8e6" id="r_ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ae95a04b1d7dccb3d9b3f3c3d087aa8e6">is_estimation_mode</a> () const</td></tr>
<tr class="memdesc:ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this sketch is in estimation mode.  <br /></td></tr>
<tr class="separator:ae95a04b1d7dccb3d9b3f3c3d087aa8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200c74c52ee0f76d0d34c1ca6aec65c" id="r_a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memTemplParams" colspan="2">template&lt;typename FwdT &gt; </td></tr>
<tr class="memitem:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a5200c74c52ee0f76d0d34c1ca6aec65c">update</a> (FwdT &amp;&amp;item)</td></tr>
<tr class="memdesc:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates this sketch with the given data item.  <br /></td></tr>
<tr class="separator:a5200c74c52ee0f76d0d34c1ca6aec65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb19e78f36fb72b8496cd6cff71fec" id="r_a49bb19e78f36fb72b8496cd6cff71fec"><td class="memTemplParams" colspan="2">template&lt;typename FwdSk &gt; </td></tr>
<tr class="memitem:a49bb19e78f36fb72b8496cd6cff71fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a49bb19e78f36fb72b8496cd6cff71fec">merge</a> (FwdSk &amp;&amp;other)</td></tr>
<tr class="memdesc:a49bb19e78f36fb72b8496cd6cff71fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges another sketch into this one.  <br /></td></tr>
<tr class="separator:a49bb19e78f36fb72b8496cd6cff71fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fa890815acf3a1418ea8eee466075c" id="r_af2fa890815acf3a1418ea8eee466075c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#af2fa890815acf3a1418ea8eee466075c">get_min_item</a> () const</td></tr>
<tr class="memdesc:af2fa890815acf3a1418ea8eee466075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the min item of the stream.  <br /></td></tr>
<tr class="separator:af2fa890815acf3a1418ea8eee466075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687ed2123bdc7e67fbda0c081e3acf21" id="r_a687ed2123bdc7e67fbda0c081e3acf21"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a687ed2123bdc7e67fbda0c081e3acf21">get_max_item</a> () const</td></tr>
<tr class="memdesc:a687ed2123bdc7e67fbda0c081e3acf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max item of the stream.  <br /></td></tr>
<tr class="separator:a687ed2123bdc7e67fbda0c081e3acf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f89979daa6471a3868cb97ea99b40" id="r_a076f89979daa6471a3868cb97ea99b40"><td class="memItemLeft" align="right" valign="top">Comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a076f89979daa6471a3868cb97ea99b40">get_comparator</a> () const</td></tr>
<tr class="memdesc:a076f89979daa6471a3868cb97ea99b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the comparator for this sketch.  <br /></td></tr>
<tr class="separator:a076f89979daa6471a3868cb97ea99b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d85cf47c4ecd0580ec623c42006dd1b" id="r_a9d85cf47c4ecd0580ec623c42006dd1b"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a9d85cf47c4ecd0580ec623c42006dd1b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a9d85cf47c4ecd0580ec623c42006dd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the allocator for this sketch.  <br /></td></tr>
<tr class="separator:a9d85cf47c4ecd0580ec623c42006dd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849dfa06c183fd2fdfe4fe4a7e29d918" id="r_a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a849dfa06c183fd2fdfe4fe4a7e29d918">get_rank</a> (const T &amp;item, bool inclusive=true) const</td></tr>
<tr class="memdesc:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the normalized rank of the given item from 0 to 1 inclusive.  <br /></td></tr>
<tr class="separator:a849dfa06c183fd2fdfe4fe4a7e29d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44226b755e73883ea2c128876e35b1d1" id="r_a44226b755e73883ea2c128876e35b1d1"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a44226b755e73883ea2c128876e35b1d1">get_PMF</a> (const T *split_points, uint32_t size, bool inclusive=true) const</td></tr>
<tr class="memdesc:a44226b755e73883ea2c128876e35b1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items).  <br /></td></tr>
<tr class="separator:a44226b755e73883ea2c128876e35b1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4d992209b2aa58614c998d143705c" id="r_a20a4d992209b2aa58614c998d143705c"><td class="memItemLeft" align="right" valign="top">vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a20a4d992209b2aa58614c998d143705c">get_CDF</a> (const T *split_points, uint32_t size, bool inclusive=true) const</td></tr>
<tr class="memdesc:a20a4d992209b2aa58614c998d143705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items).  <br /></td></tr>
<tr class="separator:a20a4d992209b2aa58614c998d143705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02fcfb6e706148458a2ef89390223a9" id="r_ac02fcfb6e706148458a2ef89390223a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1req__sketch.html#a4c80d2361c940f99df9f850615c2dcbe">quantile_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ac02fcfb6e706148458a2ef89390223a9">get_quantile</a> (double rank, bool inclusive=true) const</td></tr>
<tr class="memdesc:ac02fcfb6e706148458a2ef89390223a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximate quantile of the given normalized rank.  <br /></td></tr>
<tr class="separator:ac02fcfb6e706148458a2ef89390223a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978630658d411c9c79fffa5909f5c8d0" id="r_a978630658d411c9c79fffa5909f5c8d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a978630658d411c9c79fffa5909f5c8d0">get_rank_lower_bound</a> (double rank, uint8_t num_std_dev) const</td></tr>
<tr class="memdesc:a978630658d411c9c79fffa5909f5c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximate lower bound of the given normalized rank.  <br /></td></tr>
<tr class="separator:a978630658d411c9c79fffa5909f5c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750349aa79dff6db2d13857ab50248bb" id="r_a750349aa79dff6db2d13857ab50248bb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a750349aa79dff6db2d13857ab50248bb">get_rank_upper_bound</a> (double rank, uint8_t num_std_dev) const</td></tr>
<tr class="memdesc:a750349aa79dff6db2d13857ab50248bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximate upper bound of the given normalized rank.  <br /></td></tr>
<tr class="separator:a750349aa79dff6db2d13857ab50248bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716" id="r_ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt; std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ad9a5259d93d148b5c2050d68e7788716">get_serialized_size_bytes</a> (const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:ad9a5259d93d148b5c2050d68e7788716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size needed to serialize the current state of the sketch.  <br /></td></tr>
<tr class="separator:ad9a5259d93d148b5c2050d68e7788716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716" id="r_ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplParams" colspan="2">template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad9a5259d93d148b5c2050d68e7788716"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ad9a5259d93d148b5c2050d68e7788716">get_serialized_size_bytes</a> (const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:ad9a5259d93d148b5c2050d68e7788716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size needed to serialize the current state of the sketch.  <br /></td></tr>
<tr class="separator:ad9a5259d93d148b5c2050d68e7788716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538940c100e4353b3671ad452d3d3056" id="r_a538940c100e4353b3671ad452d3d3056"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a538940c100e4353b3671ad452d3d3056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a538940c100e4353b3671ad452d3d3056">serialize</a> (std::ostream &amp;os, const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:a538940c100e4353b3671ad452d3d3056"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method serializes the sketch into a given stream in a binary form.  <br /></td></tr>
<tr class="separator:a538940c100e4353b3671ad452d3d3056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c269c23926e93b1c7a9c00e86af97" id="r_a1d0c269c23926e93b1c7a9c00e86af97"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1d0c269c23926e93b1c7a9c00e86af97"><td class="memTemplItemLeft" align="right" valign="top">vector_bytes&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a1d0c269c23926e93b1c7a9c00e86af97">serialize</a> (unsigned header_size_bytes=0, const SerDe &amp;sd=SerDe()) const</td></tr>
<tr class="memdesc:a1d0c269c23926e93b1c7a9c00e86af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method serializes the sketch as a vector of bytes.  <br /></td></tr>
<tr class="separator:a1d0c269c23926e93b1c7a9c00e86af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a7af55659ff803b26a45552a68dda" id="r_a592a7af55659ff803b26a45552a68dda"><td class="memItemLeft" align="right" valign="top">string&lt; Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a592a7af55659ff803b26a45552a68dda">to_string</a> (bool print_levels=false, bool print_items=false) const</td></tr>
<tr class="memdesc:a592a7af55659ff803b26a45552a68dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of the sketch.  <br /></td></tr>
<tr class="separator:a592a7af55659ff803b26a45552a68dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c959a538216a09ab28c5283585956c" id="r_ad5c959a538216a09ab28c5283585956c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ad5c959a538216a09ab28c5283585956c">begin</a> () const</td></tr>
<tr class="memdesc:ad5c959a538216a09ab28c5283585956c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the first item in the sketch.  <br /></td></tr>
<tr class="separator:ad5c959a538216a09ab28c5283585956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e60e117300685401961e36f196f7a" id="r_ae11e60e117300685401961e36f196f7a"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ae11e60e117300685401961e36f196f7a">end</a> () const</td></tr>
<tr class="memdesc:ae11e60e117300685401961e36f196f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the past-the-end item in the sketch.  <br /></td></tr>
<tr class="separator:ae11e60e117300685401961e36f196f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9c9c240dd591017fd6a80e147b7c00" id="r_a0a9c9c240dd591017fd6a80e147b7c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, Comparator, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a0a9c9c240dd591017fd6a80e147b7c00">get_sorted_view</a> () const</td></tr>
<tr class="memdesc:a0a9c9c240dd591017fd6a80e147b7c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sorted view of this sketch.  <br /></td></tr>
<tr class="separator:a0a9c9c240dd591017fd6a80e147b7c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a899bef2c5e0ea489ed4b023d2b9900ee" id="r_a899bef2c5e0ea489ed4b023d2b9900ee"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a899bef2c5e0ea489ed4b023d2b9900ee">get_RSE</a> (uint16_t k, double rank, bool hra, uint64_t n)</td></tr>
<tr class="memdesc:a899bef2c5e0ea489ed4b023d2b9900ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an a priori estimate of relative standard error (RSE, expressed as a number in [0,1]).  <br /></td></tr>
<tr class="separator:a899bef2c5e0ea489ed4b023d2b9900ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1936c2c39faaf2c19243949a57cec8e0" id="r_a1936c2c39faaf2c19243949a57cec8e0"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1936c2c39faaf2c19243949a57cec8e0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#a1936c2c39faaf2c19243949a57cec8e0">deserialize</a> (std::istream &amp;is, const SerDe &amp;sd=SerDe(), const Comparator &amp;comparator=Comparator(), const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="memdesc:a1936c2c39faaf2c19243949a57cec8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method deserializes a sketch from a given stream.  <br /></td></tr>
<tr class="separator:a1936c2c39faaf2c19243949a57cec8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e9fdcb69c547de681bb6f10ae5ef3e" id="r_ae7e9fdcb69c547de681bb6f10ae5ef3e"><td class="memTemplParams" colspan="2">template&lt;typename SerDe  = serde&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae7e9fdcb69c547de681bb6f10ae5ef3e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatasketches_1_1req__sketch.html#ae7e9fdcb69c547de681bb6f10ae5ef3e">deserialize</a> (const void *bytes, size_t size, const SerDe &amp;sd=SerDe(), const Comparator &amp;comparator=Comparator(), const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="memdesc:ae7e9fdcb69c547de681bb6f10ae5ef3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method deserializes a sketch from a given array of bytes.  <br /></td></tr>
<tr class="separator:ae7e9fdcb69c547de681bb6f10ae5ef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Comparator = std::less&lt;T&gt;, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class datasketches::req_sketch&lt; T, Comparator, Allocator &gt;</div><p>Relative Error Quantiles Sketch. </p>
<p>This is an implementation based on the paper "Relative Error Streaming Quantiles" by Graham Cormode, Zohar Karnin, Edo Liberty, Justin Thaler, Pavel Veselý, and loosely derived from a Python prototype written by Pavel Veselý.</p>
<p>Reference: <a href="https://arxiv.org/abs/2004.01668">https://arxiv.org/abs/2004.01668</a></p>
<p>This implementation differs from the algorithm described in the paper in the following:</p>
<ul>
<li>
<p class="startli">The algorithm requires no upper bound on the stream length. Instead, each relative-compactor counts the number of compaction operations performed so far (via variable state). Initially, the relative-compactor starts with INIT_NUMBER_OF_SECTIONS. Each time the number of compactions (variable state) exceeds 2^{numSections - 1}, we double numSections. Note that after merging the sketch with another one variable state may not correspond to the number of compactions performed at a particular level, however, since the state variable never exceeds the number of compactions, the guarantees of the sketch remain valid.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The size of each section (variable k and section_size in the code and parameter k in the paper) is initialized with a number set by the user via variable k. When the number of sections doubles, we decrease section_size by a factor of sqrt(2). This is applied at each level separately. Thus, when we double the number of sections, the nominal compactor size increases by a factor of approx. sqrt(2) (+/- rounding).</p>
<p class="endli"></p>
</li>
<li>
The merge operation here does not perform "special compactions", which are used in the paper to allow for a tight mathematical analysis of the sketch. </li>
</ul>
<p>This implementation provides a number of capabilities not discussed in the paper or provided in the Python prototype.</p>
<ul>
<li>
The Python prototype only implemented high accuracy for low ranks. This implementation provides the user with the ability to choose either high rank accuracy or low rank accuracy at the time of sketch construction. </li>
<li>
The Python prototype only implemented a comparison criterion of "INCLUSIVE". This implementation allows the user to use both the "INCLUSIVE" criterion and the "EXCLUSIVE" criterion. </li>
<li>
This implementation provides extensive debug visibility into the operation of the sketch with two levels of detail output. This is not only useful for debugging, but is a powerful tool to help users understand how the sketch works. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4c80d2361c940f99df9f850615c2dcbe" name="a4c80d2361c940f99df9f850615c2dcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c80d2361c940f99df9f850615c2dcbe">&#9670;&#160;</a></span>quantile_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdatasketches_1_1req__sketch.html#a4c80d2361c940f99df9f850615c2dcbe">quantile_return_type</a> =  typename <a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt;T, Comparator, Allocator&gt;::quantile_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantile return type. </p>
<p>This is to return quantiles either by value (for arithmetic types) or by const reference (for all other types) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a732d80ecaa19aab05f65ca62bdf0452c" name="a732d80ecaa19aab05f65ca62bdf0452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732d80ecaa19aab05f65ca62bdf0452c">&#9670;&#160;</a></span>req_sketch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hra</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Controls the size and error of the sketch. It must be even and in the range [4, 1024], inclusive. Value of 12 roughly corresponds to 1% relative error guarantee at 95% confidence. </td></tr>
    <tr><td class="paramname">hra</td><td>if true, the default, the high ranks are prioritized for better accuracy. Otherwise the low ranks are prioritized for better accuracy. </td></tr>
    <tr><td class="paramname">comparator</td><td>strict weak ordering function (see C++ named requirements: Compare) </td></tr>
    <tr><td class="paramname">allocator</td><td>used by this sketch to allocate memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ec3122d5c0994c725123257065de56b" name="a4ec3122d5c0994c725123257065de56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec3122d5c0994c725123257065de56b">&#9670;&#160;</a></span>req_sketch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, Comparator, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25d0fc41e0544761ffc626aa70415319" name="a25d0fc41e0544761ffc626aa70415319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d0fc41e0544761ffc626aa70415319">&#9670;&#160;</a></span>req_sketch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, Comparator, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1943668612ea073d2f6381ee8c2ddfbd" name="a1943668612ea073d2f6381ee8c2ddfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1943668612ea073d2f6381ee8c2ddfbd">&#9670;&#160;</a></span>req_sketch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TT , typename CC , typename AA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; TT, CC, AA &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type converting constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch of a different type </td></tr>
    <tr><td class="paramname">comparator</td><td>instance of a Comparator </td></tr>
    <tr><td class="paramname">allocator</td><td>instance of an Allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab6e85db46b1d76086d5e9b5065b74a46" name="ab6e85db46b1d76086d5e9b5065b74a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e85db46b1d76086d5e9b5065b74a46">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, C, A &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, Comparator, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this sketch </dd></dl>

</div>
</div>
<a id="ac36e220c05c86824c475a779e2c39232" name="ac36e220c05c86824c475a779e2c39232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36e220c05c86824c475a779e2c39232">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, C, A &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a>&lt; T, Comparator, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this sketch </dd></dl>

</div>
</div>
<a id="a59f4c39b9f2e762e8e3445ef89e1d264" name="a59f4c39b9f2e762e8e3445ef89e1d264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f4c39b9f2e762e8e3445ef89e1d264">&#9670;&#160;</a></span>get_k()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_k </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns configured parameter K. </p>
<dl class="section return"><dt>Returns</dt><dd>parameter K </dd></dl>

</div>
</div>
<a id="af6177b85206272c56ee75747bb885735" name="af6177b85206272c56ee75747bb885735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6177b85206272c56ee75747bb885735">&#9670;&#160;</a></span>is_HRA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_HRA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns configured parameter High Rank Accuracy. </p>
<dl class="section return"><dt>Returns</dt><dd>parameter HRA </dd></dl>

</div>
</div>
<a id="a5a2b7a58dc85678d08752945ff655362" name="a5a2b7a58dc85678d08752945ff655362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2b7a58dc85678d08752945ff655362">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this sketch is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>empty flag </dd></dl>

</div>
</div>
<a id="af857be9469a7565252626f27e1f9d74d" name="af857be9469a7565252626f27e1f9d74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af857be9469a7565252626f27e1f9d74d">&#9670;&#160;</a></span>get_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the input stream. </p>
<dl class="section return"><dt>Returns</dt><dd>stream length </dd></dl>

</div>
</div>
<a id="a31fa76458d81a17dbebfcb828e531f14" name="a31fa76458d81a17dbebfcb828e531f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fa76458d81a17dbebfcb828e531f14">&#9670;&#160;</a></span>get_num_retained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_num_retained </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of retained items in the sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>number of retained items </dd></dl>

</div>
</div>
<a id="ae95a04b1d7dccb3d9b3f3c3d087aa8e6" name="ae95a04b1d7dccb3d9b3f3c3d087aa8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95a04b1d7dccb3d9b3f3c3d087aa8e6">&#9670;&#160;</a></span>is_estimation_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_estimation_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this sketch is in estimation mode. </p>
<dl class="section return"><dt>Returns</dt><dd>estimation mode flag </dd></dl>

</div>
</div>
<a id="a5200c74c52ee0f76d0d34c1ca6aec65c" name="a5200c74c52ee0f76d0d34c1ca6aec65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200c74c52ee0f76d0d34c1ca6aec65c">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename FwdT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void update </td>
          <td>(</td>
          <td class="paramtype">FwdT &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates this sketch with the given data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>from a stream of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49bb19e78f36fb72b8496cd6cff71fec" name="a49bb19e78f36fb72b8496cd6cff71fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bb19e78f36fb72b8496cd6cff71fec">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename FwdSk &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype">FwdSk &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges another sketch into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>sketch to merge into this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2fa890815acf3a1418ea8eee466075c" name="af2fa890815acf3a1418ea8eee466075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fa890815acf3a1418ea8eee466075c">&#9670;&#160;</a></span>get_min_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_min_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the min item of the stream. </p>
<p>If the sketch is empty this throws std::runtime_error. </p><dl class="section return"><dt>Returns</dt><dd>the min item of the stream </dd></dl>

</div>
</div>
<a id="a687ed2123bdc7e67fbda0c081e3acf21" name="a687ed2123bdc7e67fbda0c081e3acf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687ed2123bdc7e67fbda0c081e3acf21">&#9670;&#160;</a></span>get_max_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_max_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max item of the stream. </p>
<p>If the sketch is empty this throws std::runtime_error. </p><dl class="section return"><dt>Returns</dt><dd>the max item of the stream </dd></dl>

</div>
</div>
<a id="a076f89979daa6471a3868cb97ea99b40" name="a076f89979daa6471a3868cb97ea99b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076f89979daa6471a3868cb97ea99b40">&#9670;&#160;</a></span>get_comparator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C get_comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of the comparator for this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>comparator </dd></dl>

</div>
</div>
<a id="a9d85cf47c4ecd0580ec623c42006dd1b" name="a9d85cf47c4ecd0580ec623c42006dd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d85cf47c4ecd0580ec623c42006dd1b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of the allocator for this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>allocator </dd></dl>

</div>
</div>
<a id="a849dfa06c183fd2fdfe4fe4a7e29d918" name="a849dfa06c183fd2fdfe4fe4a7e29d918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849dfa06c183fd2fdfe4fe4a7e29d918">&#9670;&#160;</a></span>get_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double get_rank </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the normalized rank of the given item from 0 to 1 inclusive. </p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>to be ranked. </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the weight of the given item is included into the rank. Otherwise the rank equals the sum of the weights of all items that are less than the given item according to the comparator C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an approximate rank of the given item </dd></dl>

</div>
</div>
<a id="a44226b755e73883ea2c128876e35b1d1" name="a44226b755e73883ea2c128876e35b1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44226b755e73883ea2c128876e35b1d1">&#9670;&#160;</a></span>get_PMF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_PMF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of split points (items). </p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals (bins).</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in PMF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles each of which is an approximation to the fraction of the input stream items (the mass) that fall into one of those intervals. </dd></dl>

</div>
</div>
<a id="a20a4d992209b2aa58614c998d143705c" name="a20a4d992209b2aa58614c998d143705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4d992209b2aa58614c998d143705c">&#9670;&#160;</a></span>get_CDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_CDF </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>split_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of split points (items). </p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_points</td><td>an array of <em>m</em> unique, monotonically increasing items that divide the input domain into <em>m+1</em> consecutive disjoint intervals.</td></tr>
    <tr><td class="paramname">size</td><td>the number of split points in the array</td></tr>
    <tr><td class="paramname">inclusive</td><td>if true the rank of an item includes its own weight, and therefore if the sketch contains items equal to a slit point, then in CDF such items are included into the interval to the left of split point. Otherwise they are included into the interval to the right of split point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of m+1 doubles, which are a consecutive approximation to the CDF of the input stream given the split_points. The value at array position j of the returned CDF array is the sum of the returned values in positions 0 through j of the returned PMF array. This can be viewed as array of ranks of the given split points plus one more value that is always 1. </dd></dl>

</div>
</div>
<a id="ac02fcfb6e706148458a2ef89390223a9" name="ac02fcfb6e706148458a2ef89390223a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02fcfb6e706148458a2ef89390223a9">&#9670;&#160;</a></span>get_quantile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto get_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximate quantile of the given normalized rank. </p>
<p>The normalized rank must be in the range [0.0, 1.0] (both inclusive). </p>
<p>If the sketch is empty this throws std::runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>of an item in the hypothetical sorted stream. </td></tr>
    <tr><td class="paramname">inclusive</td><td>if true, the given rank is considered inclusive (includes weight of an item)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>approximate quantile associated with the given rank </dd></dl>

</div>
</div>
<a id="a978630658d411c9c79fffa5909f5c8d0" name="a978630658d411c9c79fffa5909f5c8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978630658d411c9c79fffa5909f5c8d0">&#9670;&#160;</a></span>get_rank_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double get_rank_lower_bound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_std_dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximate lower bound of the given normalized rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the given rank, a value between 0 and 1.0. </td></tr>
    <tr><td class="paramname">num_std_dev</td><td>the number of standard deviations. Must be 1, 2, or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an approximate lower bound rank. </dd></dl>

</div>
</div>
<a id="a750349aa79dff6db2d13857ab50248bb" name="a750349aa79dff6db2d13857ab50248bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750349aa79dff6db2d13857ab50248bb">&#9670;&#160;</a></span>get_rank_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double get_rank_upper_bound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_std_dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximate upper bound of the given normalized rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the given rank, a value between 0 and 1.0. </td></tr>
    <tr><td class="paramname">num_std_dev</td><td>the number of standard deviations. Must be 1, 2, or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an approximate upper bound rank. </dd></dl>

</div>
</div>
<a id="a899bef2c5e0ea489ed4b023d2b9900ee" name="a899bef2c5e0ea489ed4b023d2b9900ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899bef2c5e0ea489ed4b023d2b9900ee">&#9670;&#160;</a></span>get_RSE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double get_RSE </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an a priori estimate of relative standard error (RSE, expressed as a number in [0,1]). </p>
<p>Derived from Lemma 12 in <a href="https://arxiv.org/abs/2004.01668v2">https://arxiv.org/abs/2004.01668v2</a>, but the constant factors were modified based on empirical measurements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the given value of k </td></tr>
    <tr><td class="paramname">rank</td><td>the given normalized rank, a number in [0,1]. </td></tr>
    <tr><td class="paramname">hra</td><td>if true High Rank Accuracy mode is being selected, otherwise, Low Rank Accuracy. </td></tr>
    <tr><td class="paramname">n</td><td>an estimate of the total number of items submitted to the sketch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an a priori estimate of relative standard error (RSE, expressed as a number in [0,1]). </dd></dl>

</div>
</div>
<a id="ad9a5259d93d148b5c2050d68e7788716" name="ad9a5259d93d148b5c2050d68e7788716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a5259d93d148b5c2050d68e7788716">&#9670;&#160;</a></span>get_serialized_size_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename TT , typename SerDe , typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t get_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes size needed to serialize the current state of the sketch. </p>
<p>This version is for fixed-size arithmetic types (integral and floating point). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes needed to serialize this sketch </dd></dl>

</div>
</div>
<a id="ad9a5259d93d148b5c2050d68e7788716" name="ad9a5259d93d148b5c2050d68e7788716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a5259d93d148b5c2050d68e7788716">&#9670;&#160;</a></span>get_serialized_size_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TT  = T, typename SerDe  = serde&lt;T&gt;, typename std::enable_if&lt;!std::is_arithmetic&lt; TT &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t get_serialized_size_bytes </td>
          <td>(</td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes size needed to serialize the current state of the sketch. </p>
<p>This version is for all other types and can be expensive since every item needs to be looked at. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes needed to serialize this sketch </dd></dl>

</div>
</div>
<a id="a538940c100e4353b3671ad452d3d3056" name="a538940c100e4353b3671ad452d3d3056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538940c100e4353b3671ad452d3d3056">&#9670;&#160;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename SerDe &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method serializes the sketch into a given stream in a binary form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0c269c23926e93b1c7a9c00e86af97" name="a1d0c269c23926e93b1c7a9c00e86af97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c269c23926e93b1c7a9c00e86af97">&#9670;&#160;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_bytes serialize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>header_size_bytes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method serializes the sketch as a vector of bytes. </p>
<p>An optional header can be reserved in front of the sketch. It is a blank space of a given size. This header is used in Datasketches PostgreSQL extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_size_bytes</td><td>space to reserve in front of the sketch </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1936c2c39faaf2c19243949a57cec8e0" name="a1936c2c39faaf2c19243949a57cec8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1936c2c39faaf2c19243949a57cec8e0">&#9670;&#160;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method deserializes a sketch from a given stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
    <tr><td class="paramname">comparator</td><td>instance of a Comparator </td></tr>
    <tr><td class="paramname">allocator</td><td>instance of an Allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a sketch </dd></dl>

</div>
</div>
<a id="ae7e9fdcb69c547de681bb6f10ae5ef3e" name="ae7e9fdcb69c547de681bb6f10ae5ef3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e9fdcb69c547de681bb6f10ae5ef3e">&#9670;&#160;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparator  = std::less&lt;T&gt;, typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SerDe  = serde&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdatasketches_1_1req__sketch.html">req_sketch</a> deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SerDe &amp;&#160;</td>
          <td class="paramname"><em>sd</em> = <code>SerDe()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method deserializes a sketch from a given array of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>pointer to the array of bytes </td></tr>
    <tr><td class="paramname">size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">sd</td><td>instance of a SerDe </td></tr>
    <tr><td class="paramname">comparator</td><td>instance of a Comparator </td></tr>
    <tr><td class="paramname">allocator</td><td>instance of an Allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of a sketch </dd></dl>

</div>
</div>
<a id="a592a7af55659ff803b26a45552a68dda" name="a592a7af55659ff803b26a45552a68dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a7af55659ff803b26a45552a68dda">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">string&lt; A &gt; to_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_levels</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_items</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a summary of the sketch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_levels</td><td>if true include information about levels </td></tr>
    <tr><td class="paramname">print_items</td><td>if true include sketch data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5c959a538216a09ab28c5283585956c" name="ad5c959a538216a09ab28c5283585956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c959a538216a09ab28c5283585956c">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the first item in the sketch. </p>
<p>If the sketch is empty, the returned iterator must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first item in the sketch </dd></dl>

</div>
</div>
<a id="ae11e60e117300685401961e36f196f7a" name="ae11e60e117300685401961e36f196f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e60e117300685401961e36f196f7a">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the past-the-end item in the sketch. </p>
<p>The past-the-end item is the hypothetical item that would follow the last item. It does not point to any item, and must not be dereferenced or incremented. </p><dl class="section return"><dt>Returns</dt><dd>iterator pointing to the past-the-end item in the sketch </dd></dl>

</div>
</div>
<a id="a0a9c9c240dd591017fd6a80e147b7c00" name="a0a9c9c240dd591017fd6a80e147b7c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9c9c240dd591017fd6a80e147b7c00">&#9670;&#160;</a></span>get_sorted_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatasketches_1_1quantiles__sorted__view.html">quantiles_sorted_view</a>&lt; T, C, A &gt; get_sorted_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sorted view of this sketch. </p>
<dl class="section return"><dt>Returns</dt><dd>the sorted view of this sketch </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>req/include/<a class="el" href="req__sketch_8hpp_source.html">req_sketch.hpp</a></li>
<li>req/include/<a class="el" href="req__sketch__impl_8hpp_source.html">req_sketch_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
